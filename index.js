/*
Задача: написати функцію, яка приймає число у певну ступінь і приймає два аргументи
- число, яке потрібно звести у ступінь
- ступінь, у яку потрібно звести число
*/

// Ітеративне мислення: цикл for

function pow(x, n) {
  let result = 1; // змінна у якій ми будемо накопичувати добуток

  // множимо result на x, n разів у циклі
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}

console.log(pow(2, 3)); // 8

// рекурсивне мислення: спрощуємо завдання і викликаємо функцією саму себе

function powRecursive(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * powRecursive(x, n - 1);
  }
}

/*       if n === 1 ----> x
     
pow(x, n) =

        else -----> x * pow(x, n - 1)
*/

// x^n = x * x^(n-1)

/*

1. powRecursive(2, 4) --->> 2 * powRecursive(2, 3)
2. powRecursive(2, 3) --->> 2 * powRecursive(2, 2)
3. powRecursive(2, 2) --->> 2 * powRecursive(2, 1)
4. powRecursive(2, 1) --->> 2 
*/

/*
Особливості роботи:
1. Рекурсія робить виклик функції простішим, потім ще простішим і так далі, поки результат не стане очевидним (досягнення бази рекурсії)
2. Рекурсивне рішення, як правило, коростше ніж ітераційне
*/

// Кількість вкладених викликів - глибина рекурсії

// Глибина рекурсії не має перевищувати 10 000  викликів